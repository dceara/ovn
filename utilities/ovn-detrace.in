#! @PYTHON3@
#
# Copyright (c) 2017 eBay Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import getopt
import json
import jsonpickle
import os
import re
import sys
import time

try:
    from ovs.db import idl
    from ovs import jsonrpc
    from ovs.poller import Poller
    from ovs.stream import Stream
    from ovs import dirs
except Exception:
    print("ERROR: Please install the correct Open vSwitch python support")
    print("       libraries (@VERSION@).")
    print("       Alternatively, check that your PYTHONPATH is pointing to")
    print("       the correct location.")
    sys.exit(1)


argv0 = sys.argv[0]


def usage():
    print("""\
%(argv0)s:
usage: %(argv0)s < FILE
where FILE is output from ovs-appctl ofproto/trace.

The following options are also available:
  -h, --help                  display this help message
  -V, --version               display version information
  --ovnsb=DATABASE            use DATABASE as southbound DB
  --ovnnb=DATABASE            use DATABASE as northbound DB
  --ovsdb=DATABASE            use DATABASE as OVS DB
  --json                      output json instead of plain text\
""" % {'argv0': argv0})
    sys.exit(0)

def datapath_str(datapath):
    return '"%s" (%s)' % (str(datapath.external_ids.get('name')),
                          datapath.uuid)

def chassis_str(chassis):
    if len(chassis) == 0:
        return ''
    ch = chassis[0]
    return 'chassis-name "%s", chassis-str "%s"' % (ch.name, ch.hostname)

class TraceRecord(object):
    def __init__(self):
        self._flow = ''
        self._actions = ''
        self._datapath = ''
        self._pipeline = ''
        self._stage = ''
        self._sbrec = ''
        self._nbrec = ''
        self._logs = []

    def add_flow(self, flow_line):
        if flow_line.startswith('Datapath actions: '):
            self._actions += flow_line[len('Datapath actions: ') :]
            return

        if self._flow:
            self._flow += '\n'
        self._flow += flow_line

    def add_log(self, log):
        self._logs.append(log)

class TraceOutputs(object):
    def __init__(self):
        self._records = []

    def add_record(self):
        record = TraceRecord()
        self._records.append(record)
        return record

class RawPrinter(object):
    def __init__(self):
        pass

    def print_datapath(self, datapath, pipeline=None):
        print('  * Logical datapath: %s%s' %
                (datapath_str(datapath), '[%s]' % pipeline if pipeline else ''))

    def print_sbrec(self, record, stage=None):
        print('  * ' + record)

    def print_nbrec(self, record):
        print('   * ' + record)

    def print_extra(self, msg):
        print(msg)

    def begin_record(self):
        pass

    def print_flow(self, flow_line):
        print(flow_line)

    def end_record(self):
        pass

    def dump(self):
        return None

class JsonPrinter(RawPrinter):
    def __init__(self):
        super(JsonPrinter, self).__init__()
        self._output = TraceOutputs()
        self._record = None

    def print_datapath(self, datapath, pipeline=None):
        self._record._datapath = datapath_str(datapath)
        if pipeline:
            self._record._pipeline = pipeline

    def print_sbrec(self, sbrec_record, stage=None):
        self._record._sbrec = sbrec_record
        if stage:
            self._record._stage = stage

    def print_nbrec(self, nbrec_record):
        self._record._nbrec = nbrec_record

    def print_extra(self, msg):
        self._record.add_log(msg)

    def begin_record(self):
        self._record = self._output.add_record()

    def print_flow(self, flow_line):
        self._record.add_flow(flow_line)

    def end_record(self):
        self._record = None

    def dump(self):
        return jsonpickle.encode(self._output)

# By default print (indented) output to stdout.
printer = RawPrinter()

class OVSDB(object):
    @staticmethod
    def wait_for_db_change(idl):
        seq = idl.change_seqno
        stop = time.time() + 10
        while idl.change_seqno == seq and not idl.run():
            poller = Poller()
            idl.wait(poller)
            poller.block()
            if time.time() >= stop:
                raise Exception('Retry Timeout')

    def __init__(self, db_sock, schema_name):
        self._db_sock = db_sock
        self._txn = None
        schema = self._get_schema(schema_name)
        schema.register_all()
        self._idl_conn = idl.Idl(db_sock, schema)
        OVSDB.wait_for_db_change(self._idl_conn)  # Initial Sync with DB

    def _get_schema(self, schema_name):
        error, strm = Stream.open_block(Stream.open(self._db_sock))
        if error:
            raise Exception("Unable to connect to %s" % self._db_sock)
        rpc = jsonrpc.Connection(strm)
        req = jsonrpc.Message.create_request('get_schema', [schema_name])
        error, resp = rpc.transact_block(req)
        rpc.close()

        if error or resp.error:
            raise Exception('Unable to retrieve schema.')
        return idl.SchemaHelper(None, resp.result)

    def get_table(self, table_name):
        return self._idl_conn.tables[table_name]

    def _find_rows(self, table_name, find_fn):
        return filter(find_fn, self.get_table(table_name).rows.values())

    def _find_rows_by_name(self, table_name, value):
        return self._find_rows(table_name, lambda row: row.name == value)

    def find_rows_by_partial_uuid(self, table_name, value):
        return self._find_rows(table_name,
                               lambda row: str(row.uuid).startswith(value))

class CookieHandler(object):
    def __init__(self, db, table):
        self._db = db
        self._table = table

    def get_records(self, cookie):
        return []

    def print_record(self, record):
        pass

    def print_hint(self, record, db):
        pass

class CookieHandlerByUUUID(CookieHandler):
    def __init__(self, db, table):
        super(CookieHandlerByUUUID, self).__init__(db, table)

    def get_records(self, cookie):
        # Adjust cookie to include leading zeroes if needed.
        cookie = cookie.zfill(8)
        return self._db.find_rows_by_partial_uuid(self._table, cookie)

class ACLHintHandler(CookieHandlerByUUUID):
    def __init__(self, ovnnb_db):
        super(ACLHintHandler, self).__init__(ovnnb_db, 'ACL')

    def print_record(self, acl):
        output = 'ACL: %s, priority=%s, ' \
                 'match=(%s), %s' % (acl.direction,
                                     acl.priority,
                                     acl.match.strip('"'),
                                     acl.action)
        if acl.log:
            output += ' (log)'
        printer.print_nbrec(output)

class LSPHintHandler(CookieHandlerByUUUID):
    def __init__(self, ovnnb_db):
        super(LSPHintHandler, self).__init__(ovnnb_db, 'Logical_Switch_Port')

    def print_record(self, lsp):
        printer.print_nbrec('Logical Switch Port: %s type %s (addresses %s, dynamic addresses %s, security %s' % (
                    lsp.name, lsp.type, lsp.addresses, lsp.dynamic_addresses,
                    lsp.port_security))

class LRPHintHandler(CookieHandlerByUUUID):
    def __init__(self, ovnnb_db):
        super(LRPHintHandler, self).__init__(ovnnb_db, 'Logical_Router_Port')

    def print_record(self, lrp):
        printer.print_nbrec('Logical Router Port: %s mac %s networks %s ipv6_ra_configs %s' % (
                                lrp.name, lrp.mac, lrp.networks,
                                lrp.ipv6_ra_configs))

class LoadBalancerHintHandler(CookieHandlerByUUUID):
    def __init__(self, ovnnb_db):
        super(LoadBalancerHintHandler, self).__init__(ovnnb_db, 'Load_Balancer')

    def print_record(self, lb):
        printer.print_nbrec('Load Balancer: %s protocol %s vips %s ip_port_mappings %s' % (
                                lb.name, lb.protocol, lb.vips,
                                lb.ip_port_mappings))

class NATHintHandler(CookieHandlerByUUUID):
    def __init__(self, ovnnb_db):
        super(NATHintHandler, self).__init__(ovnnb_db, 'NAT')

    def print_record(self, nat):
        printer.print_nbrec('NAT: external IP %s external_mac %s logical_ip %s logical_port %s type %s' % (
                                nat.external_ip, nat.external_mac,
                                nat.logical_ip, nat.logical_port,
                                nat.type))

class StaticRouteHintHandler(CookieHandlerByUUUID):
    def __init__(self, ovnnb_db):
        super(StaticRouteHintHandler, self).__init__(ovnnb_db,
                                                     'Logical_Router_Static_Route')
    def print_record(self, route):
        printer.print_nbrec('Route: %s via %s (port %s), policy=%s' % (
                                route.ip_prefix, route.nexthop, route.output_port,
                                route.policy))

class LogicalFlowHandler(CookieHandlerByUUUID):
    def __init__(self, ovnnb_db, ovnsb_db):
        super(LogicalFlowHandler, self).__init__(ovnsb_db, 'Logical_Flow')
        self._hint_handlers = [
            ACLHintHandler(ovnnb_db),
            LSPHintHandler(ovnnb_db),
            LRPHintHandler(ovnnb_db),
            LoadBalancerHintHandler(ovnnb_db),
            NATHintHandler(ovnnb_db)
        ]

    def print_record(self, lflow):
        printer.print_datapath(lflow.logical_datapath, lflow.pipeline)
        stage = lflow.external_ids.get('stage-name')
        printer.print_sbrec('Logical flow: table=%s (%s), priority=%s, '
                            'match=(%s), actions=(%s)' %
                                (lflow.table_id, stage, lflow.priority,
                                 str(lflow.match).strip('"'),
                                 str(lflow.actions).strip('"')),
                            stage)

    def print_hint(self, lflow, ovnnb_db):
        external_ids = lflow.external_ids
        hint = external_ids.get('stage-hint')
        if not hint:
            return
        for handler in self._hint_handlers:
            for i, record in enumerate(handler.get_records(hint)):
                if i > 0:
                    printer.print_extra('[Duplicate uuid hint]')
                handler.print_record(record)

class PortBindingHandler(CookieHandlerByUUUID):
    def __init__(self, ovnsb_db):
        super(PortBindingHandler, self).__init__(ovnsb_db, 'Port_Binding')

    def print_record(self, pb):
        printer.print_datapath(pb.datapath)
        printer.print_sbrec(
            'Port Binding: logical_port "%s", tunnel_key %ld, %s' %
                (pb.logical_port, pb.tunnel_key,
                 chassis_str(pb.chassis)))

class MacBindingHandler(CookieHandlerByUUUID):
    def __init__(self, ovnsb_db):
        super(MacBindingHandler, self).__init__(ovnsb_db, 'MAC_Binding')

    def print_record(self, mb):
        printer.print_datapath(mb.datapath)
        printer.print_sbrec(
            'MAC Binding: ip "%s", logical_port "%s", mac "%s"' %
                (mb.ip, mb.logical_port, mb.mac))

class MulticastGroupHandler(CookieHandlerByUUUID):
    def __init__(self, ovnsb_db):
        super(MulticastGroupHandler, self).__init__(ovnsb_db,
                                                    'Multicast_Group')

    def print_record(self, mc):
        mc_ports = ', '.join([pb.logical_port for pb in mc.ports])

        printer.print_datapath(mc.datapath)
        printer.print_sbrec(
            'Multicast Group: name "%s", tunnel_key %ld ports: (%s)' %
                (mc.name, mc.tunnel_key, mc_ports))

class ChassisHandler(CookieHandlerByUUUID):
    def __init__(self, ovnsb_db):
        super(ChassisHandler, self).__init__(ovnsb_db, 'Chassis')

    def print_record(self, chassis):
        printer.print_sbrec('Chassis: %s' % (chassis_str([chassis])))

class OvsInterfaceHandler(CookieHandler):
    def __init__(self, ovs_db):
        super(OvsInterfaceHandler, self).__init__(ovs_db, 'Interface')

    def get_records(self, ofport):
        return self._db._find_rows(self._table,
                                   lambda intf: len(intf.ofport) > 0 and
                                        str(intf.ofport[0]) == ofport)

    def print_record(self, intf):
        printer.print_sbrec(
            'OVS Interface: %s (%s)' %
                (intf.name, intf.external_ids.get('iface-id')))

def print_record_from_cookie(ovnnb_db, cookie_handlers, cookie):
    for handler in cookie_handlers:
        for i, record in enumerate(handler.get_records(cookie)):
            if i > 0:
                printer.print_extra('[Duplicate uuid cookie]')
            handler.print_record(record)
            handler.print_hint(record, ovnnb_db)


def main():
    global printer

    try:
        options, args = getopt.gnu_getopt(sys.argv[1:], 'hV',
                                          ['help', 'version', 'ovs', 'json',
                                           'ovnsb=', 'ovnnb=', 'ovsdb='])
    except (getopt.GetoptError, geo):
        sys.stderr.write("%s: %s\n" % (argv0, geo.msg))
        sys.exit(1)

    ovnsb_db = None
    ovnnb_db = None
    ovs_db   = None
    ovs      = False

    for key, value in options:
        if key in ['-h', '--help']:
            usage()
        elif key in ['-V', '--version']:
            print("%s (Open vSwitch) @VERSION@" % argv0)
        elif key in ['--ovnsb']:
            ovnsb_db = value
        elif key in ['--ovnnb']:
            ovnnb_db = value
        elif key in ['--ovsdb']:
            ovs_db = value
        elif key in ['--ovs']:
            ovs = True
        elif key in ['--json']:
            printer = JsonPrinter()
        else:
            sys.exit(0)

    if len(args) != 0:
        sys.stderr.write("%s: non-option argument not supported "
                         "(use --help for help)\n" % argv0)
        sys.exit(1)

    ovn_rundir = os.getenv('OVN_RUNDIR', '@OVN_RUNDIR@')
    ovs_rundir = os.getenv('OVS_RUNDIR', dirs.RUNDIR)

    if not ovnsb_db:
        ovnsb_db = os.getenv('OVN_SB_DB')
        if not ovnsb_db:
            ovnsb_db = 'unix:%s/ovnsb_db.sock' % ovn_rundir

    if not ovnnb_db:
        ovnnb_db = os.getenv('OVN_NB_DB')
        if not ovnnb_db:
            ovnnb_db = 'unix:%s/ovnnb_db.sock' % ovn_rundir
    if ovs and not ovs_db:
        ovs_db = 'unix:%s/db.sock' % ovs_rundir

    ovsdb_ovnsb = OVSDB(ovnsb_db, 'OVN_Southbound')
    ovsdb_ovnnb = OVSDB(ovnnb_db, 'OVN_Northbound')

    cookie_handlers = [
        LogicalFlowHandler(ovsdb_ovnnb, ovsdb_ovnsb),
        PortBindingHandler(ovsdb_ovnsb),
        MacBindingHandler(ovsdb_ovnsb),
        MulticastGroupHandler(ovsdb_ovnsb),
        ChassisHandler(ovsdb_ovnsb)
    ]

    regex_cookie = re.compile(r'^.*cookie 0x([0-9a-fA-F]+)')
    regex_handlers = [
        (regex_cookie, cookie_handlers)
    ]

    if ovs:
        ovsdb_ovs = OVSDB(ovs_db, 'Open_vSwitch')
        regex_inport = re.compile(r'^ *[0-9]+\. *in_port=([0-9])+')
        regex_outport = re.compile(r'^ *output:([0-9]+)')
        ofport_handlers = [
            OvsInterfaceHandler(ovsdb_ovs)
        ]
        regex_handlers += [
            (regex_outport, ofport_handlers),
            (regex_inport, ofport_handlers)
        ]

    regex_table_id = re.compile(r'^ *[0-9]+\.')
    cookies = []
    printer.begin_record()
    while True:
        line = sys.stdin.readline()

        # Print record info when the current flow block ends.
        new_block = regex_table_id.match(line)
        if new_block or line.strip() == '':
            for cookie, handlers in cookies:
                print_record_from_cookie(ovsdb_ovnnb, handlers, cookie)
            cookies = []

        if new_block:
            printer.end_record()
            printer.begin_record()

        printer.print_flow(line.strip())
        if line == '':
            break

        for regex, handlers in regex_handlers:
            m = regex.match(line)
            if m:
                cookies.append((m.group(1), handlers))
    printer.end_record()

    output = printer.dump()
    if output:
        print(output)

if __name__ == "__main__":
    main()


# Local variables:
# mode: python
# End:
